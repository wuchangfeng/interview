* Httpclient 与 httpurlclient 之间的区别

  Http Client适用于web浏览器，拥有大量灵活的API，实现起来比较稳定，且其功能比较丰富，提供了很多工具，封装了http的请求头，参数，内容体，响应，还有一些高级功能，代理、COOKIE、鉴权、压缩、连接池的处理。正是因为如此，API 比较多难以修改，android 在 6.0 中抛弃了它，转而用 okhttp

  HttpURLConnection对于大部分功能都进行了包装，Http Client的高级功能代码会较复杂，另外，HttpURLConnection在Android 2.3中增加了一些Https方面的改进(包括Http Client，两者都支持https)。且在Android 4.0中增加了response cache。

  - **功能用法对比**
    - 从功能上对比，HttpClient库要丰富很多，提供了很多工具，封装了http的请求头，参数，内容体，响应，还有一些高级功能，代理、COOKIE、鉴权、压缩、连接池的处理。
    - HttpClient高级功能代码写起来比较复杂，对开发人员的要求会高一些，而HttpURLConnection对大部分工作进行了包装，屏蔽了不需要的细节，适合开发人员直接调用。
    - 另外，HttpURLConnection在2.3版本增加了一些HTTPS方面的改进，4.0版本增加一些响应的缓存。
  - **性能对比**
    - HttpUrlConnection直接支持GZIP压缩；HttpClient也支持，但要自己写代码处理。
    - HttpUrlConnection直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；HttpClient当然也能做到，但毕竟不如官方直接系统底层支持好。
    - HttpUrlConnection直接在系统层面做了缓存策略处理（4.0版本以上），加快了重复请求的速度。
    - [这篇文章](http://wj98127.iteye.com/blog/617014)对两者的速度做了一个对比，做法是两个类都使用默认的方法去请求百度的网页内容，测试结果是使用httpurlconnection耗时47ms，使用httpclient耗时641ms。httpURLConnection在速度有比较明显的优势，当然这跟压缩内容和缓存都有直接关系。

* APK 瘦身

  * 移除冗余的代码 用 proguard 来检查
  * 移除无用的资源 用 lint 工具
  * 对资源文件进行取舍
  * 优化压缩图片

* Android 横竖屏切换

  onSaveInstanceState-->
  onPause-->
  onStop-->
  onDestroy-->
  onCreate-->
  onStart-->
  onRestoreInstanceState-->
  onResume-->

  1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次

  2、设置Activity的android:configChanges="orientation"时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次

  3、设置Activity的android:configChanges="orientation|keyboardHidden"时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法

* 如何保证线程同步的安全性

  问：synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别
  答：synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是`synchronized`关键字后面括号内的对象。

  问：既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？
  答：synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。

  ​

* ontouchevent 和 ontouch 有什么区别

  onTouchListener的onTouch方法优先级比onTouchEvent高，会先触发。

  假如onTouch方法返回false会接着触发onTouchEvent，反之onTouchEvent方法不会被调用。

  内置诸如click事件的实现等等都基于onTouchEvent，假如onTouch返回true，这些事件将不会被触发。

  【1】OnTouchEvent()方法：

        onTouchEvent是手机屏幕事件的处理方法，是获取的对屏幕的各种操作，比如向左向右滑动，点击返回按钮等等。属于一个宏观的屏幕触摸监控。onTouchEvent方法是override 的Activity的方法。重新了Activity的onTouchEvent方法后，当屏幕有touch事件时，此方法就会别调用。

  【2】OnTouch方法

        onTouch()是OnTouchListener接口的方法，它是获取某一个控件的触摸事件，因此使用时，必须使用setOnTouchListener绑定到控件，然后才能鉴定该控件的触摸事件。当一个View绑定了OnTouchLister后，当有touch事件触发时，就会调用onTouch方法。通过getAction()方法可以获取当前触摸事件的状态：

  ACTION_DOWN：表示按下了屏幕的状态。
  ACTION_MOVE ：表示为移动手势
  ACTION_UP      ：表示为离开屏幕
  ACTION_CANCEL ：表示取消手势，不会由用户产生，而是由程序产生的

* Android 中如何避免 oom

  * 使用更加轻量级的数据结构 ArrayMap/SparseArray 来替代传统的 HashMap
  * 避免在 Android 中使用枚举,以及减少 Bitmap 所占的内存
  * 缩放图片比例以及尽量不要去加载大图
  * 在ListView和GridView等显示大量图片的控件里面需要使用LRU机制缓存Bitmap.

* SparseArray 的特点

  SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法

  SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间

* ArrayMap 的特点

  这个api的资料在网上可以说几乎没有，然并卵，只能看文档了 
  ArrayMap是一个<**key,value**>映射的[数据结构](http://lib.csdn.net/base/datastructure)，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。


* Java 静态方法可以被重写吗？

  如果从重写方法会有什么特点来看，我们是不能重写静态方法的。虽然就算你重写静态方法，编译器也不会报错。也就是说，如果你试图重写静态方法，Java不会阻止你这么做，但你却得不到预期的结果（重写仅对非静态方法有用）。重写指的是根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型。让我们猜一猜为什么静态方法是比较特殊的？因为它们是类的方法，所以它们在编译阶段就使用编译出来的类型进行绑定了。使用对象引用来访问静态方法只是Java设计者给程序员的自由。我们应该直接使用类名来访问静态方法，而不要使用对象引用来访问。

* 如何解决 GC 循环引用带来的问题

  GC root，几乎所有的 jvm 都是采用引用遍历的方法来解决循环引用潜在的问题

* TCP 如何保证传输可靠

  有超时重传机制，丢失重传机制

* 什么是三级缓存

  - 网络缓存, 不优先加载, 速度慢,浪费流量
  - 本地缓存, 次优先加载, 速度快
  - 内存缓存, 优先加载, 速度最快

* Android 中的 IPC 机制

  * 使用文件
  * 使用 messager
  * 使用 socket
  * 使用 contentprovider
  * 使用 bundle
  * 使用 AIDL

* AIDL 机制，其实就是 android 中的 ipc 机制

  所谓AIDL：Android Interface Definition Language，是一种Android接口定义语言，用于编写Android进程间通信代码。也就是说AIDL只是一个实现进程间通信的一个工具，真正实现Android进程间通信机制的其实是幕后“主谋”Binder机制。所有有关AIDL实现进程间通信都是依赖于Android的Binder机制，那么这个Binder机制到底是个什么东西呢？

  AIDL适用场景

  官方文档特别提醒我们何时使用AIDL是必要的：只有你允许客户端从不同的应用程序为了进程间的通信而去访问你的service，以及想在你的service处理多线程。具体的不同场景下的AIDL设计规则如下：

  如果不需要进行不同应用程序间的并发通信(IPC)，通过实现一个Binder对象来创建接口；或者你想进行IPC，但不需要处理多线程的，则使用Messenger对象来创建接口。无论如何，在使用AIDL前，必须要理解如何绑定service——bindService。

  AIDL开发步骤

  AIDL接口文件，和普通的接口内容没有什么特别，只是它的扩展名为.aidl，保存在src目录下。如果其他应用程序需要IPC，则那些应用程序的src也要带有这个文件。Android SDK tools就会在gen目录自动生成一个IBinder接口文件。service必须适当地实现这个IBinder接口。那么客户端程序就能绑定这个service并在IPC时从IBinder调用方法。每个aidl文件只能定义一个接口，而且只能是接口的声明和方法的声明。

  换言之，AIDL文件的作用即是在任何需要跨进程调用的方法都需要声明在涉及的每一个服务或者进程中。

* service 生命周期

  Service对象不能自己启动，需要通过某个Activity、Service或者其他Context对象来启动。启动的方法有两种，Context.startService和Context.bindService()。两种方式的生命周期是不同的，具体如下所示。

  Context.startService方式的生命周期： 
  启动时，startService –> onCreate() –> onStart() 
  停止时，stopService –> onDestroy()

  Context.bindService方式的生命周期： 
  绑定时,bindService  -> onCreate() –> onBind() 
  解绑定时,unbindService –>onUnbind() –> onDestory()

* Java NIO  https://github.com/GeniusVJR/LearningNotes/blob/master/Part2/JavaConcurrent/NIO.md

* srcoll 工作原理

  Scroller的工作原理：Scroller本身并不能实现view的滑动，它需要配合**view的computeScroll方法**才能完成弹性滑动的效果，它不断地让view重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出view的当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成view的滑动。就这样，view的每一次重绘都会导致view进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作原理。

* view 的滑动冲突的解决

  (1)常见的滑动冲突的场景：

  1.外部滑动方向和内部滑动方向不一致，例如viewpager中包含listview；

  2.外部滑动方向和内部滑动方向一致，例如viewpager的单页中存在可以滑动的bannerview；

  3.上面两种情况的嵌套，例如viewpager的单个页面中包含了bannerview和listview。

  (2)滑动冲突处理规则

  可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等

  (3)解决方式

  1.外部拦截法：点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的`onInterceptTouchEvent`方法，在内部做相应的拦截即可，其他均不需要做修改。

  2.内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不一致，需要配合`requestDisallowInterceptTouchEvent`方法才能正常工作。

* HandlerThread 始终是一个 thread，如果是 thread 的话不能直接创建 handler，但是 handlerThread 不一样，它与一般的 thread 的 run 方法不一样，一般的 run 方法中是执行耗时操作，但是 handlerthread 中的 run 方法中执行的是 looper.prepare() 和 looper.loop() 方法，所以 可以在 handlerthread 中创建 handler。

* 属性动画

  新引入的属性动画机制已经不再是针对于View来设计的了，也不限定于只能实现移动、缩放、旋转和淡入淡出这几种动画操作，同时也不再只是一种视觉上的动画效果了。它实际上是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性。所以我们仍然可以将一个View进行移动或者缩放，但同时也可以对自定义View中的Point对象进行动画操作了。我们只需要告诉系统动画的运行时长，需要执行哪种类型的动画，以及动画的初始值和结束值，剩下的工作就可以全部交给系统去完成了。

  * valueanimator
  * objectanimator

* **APK 打包流程**

  1、打包资源文件，生成R.java文件

  2、处理aidl文件，生成相应java 文件

  3、编译工程源代码，生成相应class 文件

  4、转换所有class文件，生成classes.dex文件

  5、打包生成apk

  6、对apk文件进行签名

  7、对签名后的apk文件进行对其处理

* Java 中的异常

  - **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。

  - **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。

  - **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

  - finally 关键字用来创建在 try 代码块后面执行的代码块。

    无论是否发生异常，finally 代码块中的代码总会被执行。

    在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。

  - **throws 用于抛出方法层次的异常**， 
    并且直接由些方法调用异常处理类来处理该异常， 
    所以它常用在方法的后面。比如 
    public static void main(String[] args) throws SQLException

    **throw 用于方法块里面的代码**，比throws的层次要低，比如try...catch ....语句块，表示它抛出异常， 
    但它不会处理它， 而是由方法块的throws Exception来调用异常处理类来处理。

    throw用在程序中，明确表示这里抛出一个异常。   
    throws用在方法声明的地方，表示这个方法可能会抛出某异常。

    throw是抛出一个具体的异常类，产生一个异常。
    throws则是在方法名后标出该方法会产生何种异常需要方法的使用者捕获并处理。

* Butterknife 最新的实现原理，主要是利用 APT 在编译期生成相关代码  https://joyrun.github.io/2016/07/19/AptHelloWorld/

  APT(Annotation Processing Tool)是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。
  Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。


* view 动画(视图动画) 的缺点

  * 只针对 View 对象进行动画

  * 然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作

  * 就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下

    ​

    ​

    ​

    ​

    ​

    ​

  ​

  ​